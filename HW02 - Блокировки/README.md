# Цель
Понять как работает механизм блокировок объектов и строк.

# Описание/Пошаговая инструкция выполнения домашнего задания
- Настройте сервер так, чтобы в журнал сообщений сбрасывалась информация о блокировках, удерживаемых более 200 миллисекунд.  
Воспроизведите ситуацию, при которой в журнале появятся такие сообщения.
- Смоделируйте ситуацию обновления одной и той же строки тремя командами UPDATE в разных сеансах.  
Изучите возникшие блокировки в представлении pg_locks и убедитесь, что все они понятны.
- Воспроизведите взаимоблокировку трех транзакций.  
Можно ли разобраться в ситуации постфактум, изучая журнал сообщений?

# Ход выполнения задания
## 1. Настройте сервер так, чтобы в журнал сообщений сбрасывалась информация о блокировках, удерживаемых более 200 миллисекунд.

``` sql
ALTER SYSTEM SET log_lock_waits = on;
ALTER SYSTEM SET deadlock_timeout='200ms';
SELECT pg_reload_conf();

SELECT name, setting
FROM pg_settings
WHERE name IN ('log_lock_waits', 'deadlock_timeout');
```

|       name       | setting
|------------------|---------
| deadlock_timeout | 200
| log_lock_waits   | on

### Воспроизведите ситуацию, при которой в журнале появятся такие сообщения.

Создадим БД и таблицу:
``` sql
CREATE DATABASE hw02;

CREATE TABLE t1(
  id int,
  val text
);

INSERT INTO t1(id, val) VALUES (1,'foo'),(2,'bar'),(3,'q');

SELECT * FROM t1;
```

| id | val
|----|-----
|  1 | foo
|  2 | bar
|  3 | q


Попробуем создать блокировку:
<table>
  <tr><th>TERM#1</th><th>TERM#2</th></tr>
  <tr><td>

```
hw02=# BEGIN;
BEGIN

hw02=*# SELECT pg_backend_pid();
 pg_backend_pid
----------------
         193881
(1 строка)

hw02=*# SELECT txid_current();
 txid_current
--------------
       174781
(1 строка)
```

</td><td>

```
hw02=# BEGIN;
BEGIN

hw02=*# SELECT pg_backend_pid();
 pg_backend_pid
----------------
         194079
(1 строка)

hw02=*# SELECT txid_current();
 txid_current
--------------
       174782
(1 строка)
```

</td></tr>

  <tr><td>

```
hw02=*# UPDATE t1 SET val = 'w' WHERE id = 3;
UPDATE 1
hw02=*#
```

  </td><td>

```
hw02=*# UPDATE t1 SET val = 'e' WHERE id = 3;
```

  </td></tr>
</table>

Мы должны получить запись в журнале о том, что процесс 193881 (транзакция 174781) создал блокировку и "мешает" процессу 194079 (транзакции 174782).

``` bash
tail /var/lib/pgsql/17/data/log/postgresql-Sat.log
```

``` log
2025-05-31 12:11:04.303 MSK [194079] СООБЩЕНИЕ:  процесс 194079 продолжает ожидать в режиме ShareLock блокировку "транзакция 174781" в течение 200.713 мс
2025-05-31 12:11:04.303 MSK [194079] ПОДРОБНОСТИ:  Process holding the lock: 193881. Wait queue: 194079.
2025-05-31 12:11:04.303 MSK [194079] КОНТЕКСТ:  при изменении кортежа (0,5) в отношении "t1"
2025-05-31 12:11:04.303 MSK [194079] ОПЕРАТОР:  UPDATE t1 SET val = 'e' WHERE id = 3;
```

Действительно, процесс во втором терминале ожидает снятие блокировки, созданную транзакцией в первом териминале.


## 2. Смоделируйте ситуацию обновления одной и той же строки тремя командами UPDATE в разных сеансах.
<table>
  <tr><th>TERM#1</th><th>TERM#2</th><th>TERM#3</th></tr>
  <tr><td>

```
hw02=# BEGIN;
BEGIN
hw02=*# SELECT pg_backend_pid(), txid_current();
 pg_backend_pid | txid_current
----------------+--------------
         193881 |       174788
(1 строка)

hw02=*# UPDATE t1 SET val = 's1' WHERE id = 1;
UPDATE 1
hw02=*#
```

  </td><td>

```
hw02=# BEGIN;
BEGIN
hw02=*# SELECT pg_backend_pid(), txid_current();
 pg_backend_pid | txid_current
----------------+--------------
         194079 |       174789
(1 строка)

hw02=*# UPDATE t1 SET val = 's2' WHERE id = 1;
```

  </td><td>

```
hw02=# BEGIN;
BEGIN
hw02=*# SELECT pg_backend_pid(), txid_current();
 pg_backend_pid | txid_current
----------------+--------------
         196118 |       174790
(1 строка)

hw02=*# UPDATE t1 SET val = 's3' WHERE id = 1;
```

  </td></tr>
</table>

### Изучите возникшие блокировки в представлении pg_locks и убедитесь, что все они понятны.
Ожидаемое поведение:
- Первая транзакция должна создать блокировку.
- Вторая транзакция должна ожидать снятие блокировки первой транзакции, создав при этом свою блокировку.
- Поведение третьей транзакции аналогична второй, только ожидает снятие второй блокировки.

``` bash
tail /var/lib/pgsql/17/data/log/postgresql-Sat.log
```
``` log
2025-05-31 15:28:44.936 MSK [194079] СООБЩЕНИЕ:  процесс 194079 продолжает ожидать в режиме ShareLock блокировку "транзакция 174788" в течение 200.175 мс
2025-05-31 15:28:44.936 MSK [194079] ПОДРОБНОСТИ:  Process holding the lock: 193881. Wait queue: 194079.
2025-05-31 15:28:44.936 MSK [194079] КОНТЕКСТ:  при изменении кортежа (0,10) в отношении "t1"
2025-05-31 15:28:44.936 MSK [194079] ОПЕРАТОР:  UPDATE t1 SET val = 's2' WHERE id = 1;
2025-05-31 15:28:56.297 MSK [196118] СООБЩЕНИЕ:  процесс 196118 продолжает ожидать в режиме ExclusiveLock блокировку "кортеж (0,10) отношения 16440 базы данных 16439" в течение 200.486 мс
2025-05-31 15:28:56.297 MSK [196118] ПОДРОБНОСТИ:  Process holding the lock: 194079. Wait queue: 196118.
2025-05-31 15:28:56.297 MSK [196118] ОПЕРАТОР:  UPDATE t1 SET val = 's3' WHERE id = 1;
```

Судя по логу фактическое поведение, совпадает с ожидаемым - процессы ожидают завершения друг друга.

Проверим блокировки для каждого процесса:

``` bash
echo "SELECT locktype, relation::REGCLASS, virtualxid AS virtxid, transactionid AS xid, mode, granted FROM pg_locks WHERE pid = 193881;" | sudo -u postgres psql
```

|   locktype    | relation | virtxid |  xid   |       mode       | granted
|---------------|----------|---------|--------|------------------|---------
| relation      | 16440    |         |        | RowExclusiveLock | t
| virtualxid    |          | 43/11   |        | ExclusiveLock    | t
| transactionid |          |         | 174788 | ExclusiveLock    | t

Первый процесс создает исключительные (ExclusiveLock) блокировки на номера своих транзакций (transactionid) и виртуальной транзакции (virtualxid).
Так же была создана блокировка (RowExclusiveLock) на изменяемую строку.
Данные блокировки будут присутсвовать во всех рассматриваемых транзакциях.

``` bash
echo "SELECT locktype, relation::REGCLASS, virtualxid AS virtxid, transactionid AS xid, mode, granted FROM pg_locks WHERE pid = 194079;" | sudo -u postgres psql
```

|   locktype    | relation | virtxid |  xid   |       mode       | granted
|---------------|----------|---------|--------|------------------|---------
| relation      | 16440    |         |        | RowExclusiveLock | t
| virtualxid    |          | 45/6    |        | ExclusiveLock    | t
| transactionid |          |         | 174789 | ExclusiveLock    | t
| transactionid |          |         | 174788 | ShareLock        | f
| tuple         | 16440    |         |        | ExclusiveLock    | t

Второй процесс "подвис" из-за того, что не может создать блокировку "ShareLock" из-за наличия блокировки "ExclusiveLock" в первой транзакции.
Так же была создана блокировка на кортеж, так как строка была уже обновлена в первом процессе, а мы пытаемся обновить одну и туже строку в трех транзаакциях.

``` bash
echo "SELECT locktype, relation::REGCLASS, virtualxid AS virtxid, transactionid AS xid, mode, granted FROM pg_locks WHERE pid = 196118;" | sudo -u postgres psql
```

|   locktype    | relation | virtxid |  xid   |       mode       | granted
|---------------|----------|---------|--------|------------------|---------
| relation      | 16440    |         |        | RowExclusiveLock | t
| virtualxid    |          | 48/3    |        | ExclusiveLock    | t
| tuple         | 16440    |         |        | ExclusiveLock    | f
| transactionid |          |         | 174790 | ExclusiveLock    | t

Третий процесс "подвис" в ожидании создания блокировки на кортеж, который занят вторым процессом.

## 3. Воспроизведите взаимоблокировку трех транзакций.  

<table>
  <tr><th>TERM#1</th><th>TERM#2</th><th>TERM#3</th></tr>
  <tr><td>

```
hw02=# BEGIN;
BEGIN
hw02=*# SELECT pg_backend_pid(), txid_current();
 pg_backend_pid | txid_current
----------------+--------------
         193881 |       174792
(1 строка)
```

  </td><td>

```
hw02=# BEGIN;
BEGIN
hw02=*# SELECT pg_backend_pid(), txid_current();
 pg_backend_pid | txid_current
----------------+--------------
         194079 |       174793
(1 строка)
```

  </td><td>

```
hw02=# BEGIN;
BEGIN
hw02=*# SELECT pg_backend_pid(), txid_current();
 pg_backend_pid | txid_current
----------------+--------------
         196118 |       174794
(1 строка)
```

  </td></tr>
  <tr><td>

```
hw02=*# UPDATE t1 SET val = 's1' WHERE id = 1;
UPDATE 1
```

  </td><td>

```
hw02=*# UPDATE t1 SET val = 's2' WHERE id = 2;
UPDATE 1
```

  </td><td>

```
hw02=*# UPDATE t1 SET val = 's3' WHERE id = 3;
UPDATE 1
```

  </td></tr>
  <tr><td>

```
hw02=*# UPDATE t1 SET val = 's1' WHERE id = 2;
```

  </td><td>

```
hw02=*# UPDATE t1 SET val = 's2' WHERE id = 3;
UPDATE 1
hw02=*#
```

  </td><td>

```
hw02=*# UPDATE t1 SET val = 's3' WHERE id = 1;
ОШИБКА:  обнаружена взаимоблокировка
ПОДРОБНОСТИ:  Процесс 196118 ожидает в режиме ShareLock блокировку "транзакция 174792"; заблокирован процессом 193881.
Процесс 193881 ожидает в режиме ShareLock блокировку "транзакция 174793"; заблокирован процессом 194079.
Процесс 194079 ожидает в режиме ShareLock блокировку "транзакция 174794"; заблокирован процессом 196118.
ПОДСКАЗКА:  Подробности запроса смотрите в протоколе сервера.
КОНТЕКСТ:  при изменении кортежа (0,13) в отношении "t1"
hw02=!#
```

  </td></tr>
</table>

Как видим случилась взаимоблокировка, в результате кторой PostgreSQL преравл транзакцию в 3 терминале.

### Можно ли разобраться в ситуации постфактум, изучая журнал сообщений?

``` bash
tail /var/lib/pgsql/17/data/log/postgresql-Sat.log
```
``` log
2025-05-31 16:50:20.481 MSK [193881] СООБЩЕНИЕ:  процесс 193881 продолжает ожидать в режиме ShareLock блокировку "транза
кция 174793" в течение 200.499 мс
2025-05-31 16:50:20.481 MSK [193881] ПОДРОБНОСТИ:  Process holding the lock: 194079. Wait queue: 193881.
2025-05-31 16:50:20.481 MSK [193881] КОНТЕКСТ:  при изменении кортежа (0,2) в отношении "t1"
2025-05-31 16:50:20.481 MSK [193881] ОПЕРАТОР:  UPDATE t1 SET val = 's1' WHERE id = 2;
2025-05-31 16:50:36.273 MSK [194079] СООБЩЕНИЕ:  процесс 194079 продолжает ожидать в режиме ShareLock блокировку "транзакция 174794" в течение 200.481 мс
2025-05-31 16:50:36.273 MSK [194079] ПОДРОБНОСТИ:  Process holding the lock: 196118. Wait queue: 194079.
2025-05-31 16:50:36.273 MSK [194079] КОНТЕКСТ:  при изменении кортежа (0,7) в отношении "t1"
2025-05-31 16:50:36.273 MSK [194079] ОПЕРАТОР:  UPDATE t1 SET val = 's2' WHERE id = 3;
2025-05-31 16:50:43.479 MSK [196118] СООБЩЕНИЕ:  процесс 196118 обнаружил взаимоблокировку, ожидая в режиме ShareLock блокировку "транзакция 174792" в течение 200.483 мс
2025-05-31 16:50:43.479 MSK [196118] ПОДРОБНОСТИ:  Process holding the lock: 193881. Wait queue: .
2025-05-31 16:50:43.479 MSK [196118] КОНТЕКСТ:  при изменении кортежа (0,13) в отношении "t1"
2025-05-31 16:50:43.479 MSK [196118] ОПЕРАТОР:  UPDATE t1 SET val = 's3' WHERE id = 1;
2025-05-31 16:50:43.479 MSK [196118] ОШИБКА:  обнаружена взаимоблокировка
2025-05-31 16:50:43.479 MSK [196118] ПОДРОБНОСТИ:  Процесс 196118 ожидает в режиме ShareLock блокировку "транзакция 174792"; заблокирован процессом 193881.
        Процесс 193881 ожидает в режиме ShareLock блокировку "транзакция 174793"; заблокирован процессом 194079.
        Процесс 194079 ожидает в режиме ShareLock блокировку "транзакция 174794"; заблокирован процессом 196118.
        Процесс 196118: UPDATE t1 SET val = 's3' WHERE id = 1;
        Процесс 193881: UPDATE t1 SET val = 's1' WHERE id = 2;
        Процесс 194079: UPDATE t1 SET val = 's2' WHERE id = 3;
2025-05-31 16:50:43.479 MSK [196118] ПОДСКАЗКА:  Подробности запроса смотрите в протоколе сервера.
2025-05-31 16:50:43.479 MSK [196118] КОНТЕКСТ:  при изменении кортежа (0,13) в отношении "t1"
2025-05-31 16:50:43.479 MSK [196118] ОПЕРАТОР:  UPDATE t1 SET val = 's3' WHERE id = 1;
2025-05-31 16:50:43.480 MSK [194079] СООБЩЕНИЕ:  процесс 194079 получил в режиме ShareLock блокировку "транзакция 174794" через 7407.413 мс
2025-05-31 16:50:43.480 MSK [194079] КОНТЕКСТ:  при изменении кортежа (0,7) в отношении "t1"
2025-05-31 16:50:43.480 MSK [194079] ОПЕРАТОР:  UPDATE t1 SET val = 's2' WHERE id = 3;
```

Как видим в логе появилась запись об обнаружении взаимоблокировки и подробности какие процессы/транзакции/запросы его вызвали.